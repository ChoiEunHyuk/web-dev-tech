## **🔹 인덱스(Index)란?**

- *인덱스(Index)**는 **데이터베이스에서 검색 속도를 향상시키기 위해 사용하는 자료구조**입니다.

책의 **목차(색인)**와 같은 개념으로, 테이블에서 데이터를 빠르게 찾을 수 있도록 도와줍니다.

---

## **🔹 인덱스의 특징**

1. **검색 속도 향상 (Query Performance Boost)**
    - 테이블에서 원하는 데이터를 검색할 때 **전체 데이터를 탐색(Full Table Scan)하는 대신, 인덱스를 사용하면 훨씬 빠르게 찾을 수 있음**.
    - 예를 들어, **전화번호부에서 특정 이름을 찾는 것과 비슷함**.
2. **데이터 삽입, 수정, 삭제 성능 저하 가능**
    - 인덱스를 추가하면 검색 성능은 향상되지만, 데이터를 삽입(`INSERT`), 수정(`UPDATE`), 삭제(`DELETE`)할 때 인덱스도 함께 갱신해야 하므로 **성능이 다소 저하될 수 있음**.
3. **자동 정렬 기능 제공 (Clustered Index)**
    - 일부 인덱스는 데이터가 **자동으로 정렬(Clustered Index)되도록 도와줌**.
    - 일반적으로 **Primary Key는 자동으로 Clustered Index로 설정됨**.
4. **중복 데이터 제거 가능 (Unique Index)**
    - 특정 컬럼에 대해 **유니크(Unique) 인덱스를 설정하면 중복 데이터를 방지**할 수 있음.

---

## **🔹 인덱스의 종류**

### **1. 기본 인덱스 (Primary Index, Clustered Index)**

- **기본 키(Primary Key)에 자동으로 생성되는 인덱스**.
- **데이터가 실제로 인덱스 순서에 따라 정렬됨**.
- 한 테이블에 **하나의 Clustered Index만 존재 가능**.

✅ **예제 (Primary Key 자동 인덱스)**

```sql

CREATE TABLE users (
    id INT PRIMARY KEY,  -- 자동으로 Clustered Index 생성
    name VARCHAR(100),
    email VARCHAR(100)
);

```

---

### **2. 보조 인덱스 (Secondary Index, Non-Clustered Index)**

- 테이블의 **기본 키가 아닌 컬럼에 대해 생성하는 인덱스**.
- 데이터 정렬과 무관하며, **참조용 인덱스**로 사용됨.

✅ **예제 (이메일 컬럼에 인덱스 추가)**

```sql

CREATE INDEX idx_email ON users(email);

```

- `email` 컬럼을 기준으로 검색할 때 속도가 향상됨.
- 기존 데이터 정렬 순서는 변경되지 않음.

✅ **조회 속도 차이**

```sql

SELECT * FROM users WHERE email = 'example@gmail.com';
-- 인덱스가 없으면 전체 테이블 검색 (느림)
-- 인덱스가 있으면 빠르게 탐색

```

---

### **3. 유니크 인덱스 (Unique Index)**

- **중복을 허용하지 않는 인덱스**.
- `PRIMARY KEY`와 비슷하지만, 테이블당 여러 개의 유니크 인덱스를 가질 수 있음.

✅ **예제 (이메일 중복 방지)**

```sql

CREATE UNIQUE INDEX idx_unique_email ON users(email);

```

- `email`이 중복되면 `INSERT` 또는 `UPDATE` 시 오류 발생.

---

### **4. 복합(다중) 인덱스 (Composite Index)**

- **여러 개의 컬럼을 하나의 인덱스로 설정**하여 검색 속도를 향상시킴.
- **검색 조건에 여러 컬럼이 포함될 때 유용**함.

✅ **예제 (이름과 이메일을 함께 인덱스로 설정)**

```sql

CREATE INDEX idx_name_email ON users(name, email);

```

📌 **사용 예시**

```sql

SELECT * FROM users WHERE name = 'Alice' AND email = 'alice@example.com';

```

- `name`과 `email`을 함께 조회할 때 성능이 향상됨.

---

### **5. 풀텍스트(Full-Text) 인덱스**

- **긴 텍스트 데이터에서 검색 성능을 향상시키기 위한 인덱스**.
- 일반적인 `LIKE` 검색보다 **훨씬 빠른 텍스트 검색 제공**.

✅ **예제 (MySQL에서 `FULLTEXT` 인덱스 생성)**

```sql

CREATE FULLTEXT INDEX idx_fulltext ON articles(content);

```

📌 **검색 예시**

```sql

SELECT * FROM articles WHERE MATCH(content) AGAINST('database');

```

- `content` 컬럼에서 "database"라는 단어가 포함된 문서를 빠르게 찾음.

---

## **🔹 인덱스가 있는 경우 vs 없는 경우 성능 차이**

### **✅ 인덱스가 없는 경우 (Full Table Scan)**

```sql

SELECT * FROM users WHERE email = 'user@example.com';

```

- `email` 컬럼에 **인덱스가 없으면** 전체 테이블을 탐색(Full Table Scan)하여 데이터를 찾음.
- 데이터가 많을수록 **검색 속도가 느려짐**.

### **✅ 인덱스가 있는 경우 (Index Scan)**

```sql

CREATE INDEX idx_email ON users(email);
SELECT * FROM users WHERE email = 'user@example.com';

```

- `email` 컬럼에 **인덱스를 생성하면** 특정 이메일을 빠르게 검색할 수 있음.
- 테이블 크기가 커질수록 속도 차이가 더욱 커짐.

---

## **🔹 인덱스의 단점**

✅ **데이터 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 속도가 느려질 수 있음**

- 인덱스를 업데이트해야 하므로 추가적인 연산이 필요함.

✅ **디스크 공간을 추가로 사용함**

- 인덱스를 저장하기 위해 **추가적인 메모리와 디스크 공간**이 필요함.

✅ **잘못된 인덱스 사용은 오히려 성능을 저하시킬 수 있음**

- 너무 많은 인덱스를 사용하면 **오버헤드(부하)**가 발생할 수 있음.
- 자주 변경되는 컬럼에 인덱스를 설정하면 **매번 인덱스를 업데이트해야 하므로 성능이 저하될 수 있음**.

---

## **🔹 인덱스 삭제 및 최적화**

### **✅ 인덱스 삭제**

```sql

DROP INDEX idx_email ON users;

```

- `email` 컬럼에 생성한 `idx_email` 인덱스를 삭제.

### **✅ 인덱스 최적화 (Rebuild Index)**

```sql

ALTER TABLE users DROP INDEX idx_email;
ALTER TABLE users ADD INDEX idx_email (email);

```

- 인덱스를 삭제 후 다시 생성하여 최적화 가능.

---

## **🔹 언제 인덱스를 사용해야 할까?**

### **✅ 인덱스 사용이 적합한 경우**

✔ `WHERE` 조건절에서 자주 사용되는 컬럼

✔ `JOIN` 조건에 사용되는 컬럼

✔ `ORDER BY`, `GROUP BY`에서 정렬 성능을 향상시키기 위해

✔ 데이터가 많고 자주 조회되는 컬럼

### **❌ 인덱스를 사용하지 않는 것이 좋은 경우**

❌ 데이터 변경(INSERT, UPDATE, DELETE)이 매우 자주 발생하는 컬럼

❌ `WHERE` 조건에 거의 사용되지 않는 컬럼

❌ 테이블 크기가 작아서 인덱스가 필요 없는 경우

---

## **🔹 결론**

✅ **인덱스는 검색 속도를 향상시키는 데이터베이스의 핵심 최적화 기술**입니다.

✅ **Primary Key는 기본적으로 Clustered Index가 생성되며, Secondary Index를 추가하여 조회 성능을 향상시킬 수 있음**.

✅ **하지만, 인덱스를 너무 많이 사용하면 데이터 삽입/수정/삭제 성능이 저하될 수 있으므로 신중하게 사용해야 함**.

✅ **적절한 인덱스 설계를 통해 성능을 최적화하는 것이 중요함**.
