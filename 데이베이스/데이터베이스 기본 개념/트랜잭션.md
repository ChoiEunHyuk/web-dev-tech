### **🔹 트랜잭션(Transaction) 개념**

트랜잭션(Transaction)이란 **데이터베이스에서 하나의 논리적인 작업 단위를 이루는 연산들의 집합**입니다.

즉, 여러 개의 SQL 문을 하나의 단위로 묶어 **모두 성공하거나, 하나라도 실패하면 전체를 되돌리는(ROLLBACK) 기능**을 제공합니다.

트랜잭션을 사용하면 데이터의 **일관성(Consistency)**과 **무결성(Integrity)**을 보장할 수 있습니다.

---

## **🔹 트랜잭션의 주요 특징 (ACID 원칙)**

트랜잭션은 **ACID**(원자성, 일관성, 독립성, 지속성) 속성을 만족해야 합니다.

| **ACID 원칙** | **설명** |
| --- | --- |
| **A (Atomicity, 원자성)** | 트랜잭션은 **모두 성공하거나, 하나라도 실패하면 전체를 취소(ROLLBACK)**해야 함 |
| **C (Consistency, 일관성)** | 트랜잭션 수행 전후 데이터의 **일관성이 유지**되어야 함 |
| **I (Isolation, 격리성)** | 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션이 영향을 주어서는 안 됨 |
| **D (Durability, 지속성)** | 트랜잭션이 **성공적으로 수행된 후에는 반드시 데이터가 영구적으로 저장**되어야 함 |

---

## **🔹 트랜잭션 사용 예제**

### **✅ 1. 트랜잭션이 필요한 상황**

예를 들어, 은행에서 **A 계좌에서 B 계좌로 송금하는 경우**, 두 개의 작업이 필요합니다.

1. A 계좌에서 **100,000원 출금**
2. B 계좌에 **100,000원 입금**

만약 1번이 성공했지만, 2번이 실패한다면 **출금만 되고 입금이 되지 않는 문제**가 발생할 수 있습니다.

이런 경우, **트랜잭션을 사용하여 하나라도 실패하면 모든 작업을 취소(ROLLBACK)** 해야 합니다.

---

### **✅ 2. 트랜잭션 기본 사용법 (MySQL, PostgreSQL, Oracle)**

```sql
sql
복사편집
START TRANSACTION;  -- 트랜잭션 시작

UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A';  -- A 계좌 출금
UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B';  -- B 계좌 입금

COMMIT;  -- 모든 작업이 성공하면 적용

```

- `START TRANSACTION;` → 트랜잭션 시작
- `COMMIT;` → 모든 작업이 성공하면 **변경 사항을 데이터베이스에 저장**

---

### **✅ 3. 트랜잭션 롤백 (ROLLBACK)**

만약 실행 도중 **오류가 발생하면 이전 상태로 되돌려야 함** (예: A 계좌에서 출금했지만, B 계좌에 입금 실패).

```sql
sql
복사편집
START TRANSACTION;

UPDATE accounts SET balance = balance - 100000 WHERE account_id = 'A';  -- A 계좌 출금

-- 오류 발생 (예: 네트워크 문제, 계좌 존재하지 않음)
IF ERROR THEN
    ROLLBACK;  -- 모든 변경 사항 취소
ELSE
    UPDATE accounts SET balance = balance + 100000 WHERE account_id = 'B';  -- B 계좌 입금
    COMMIT;  -- 성공 시 반영
END IF;

```

- `ROLLBACK;` → 하나라도 실패하면 모든 변경 사항을 취소하여 **데이터 일관성을 유지**함

---

### **✅ 4. Auto Commit 설정**

- 기본적으로 MySQL, PostgreSQL 등의 데이터베이스는 `AUTOCOMMIT` 모드가 활성화되어 있음.
- 즉, **각 SQL 문이 자동으로 Commit** 됨.
- 이를 방지하려면 `SET AUTOCOMMIT = OFF;`를 설정하여 명시적으로 `COMMIT;`을 실행해야 함.

```sql
sql
복사편집
SET AUTOCOMMIT = OFF;  -- 자동 커밋 비활성화
START TRANSACTION;

UPDATE users SET points = points - 10 WHERE user_id = 1;  -- 포인트 차감
UPDATE users SET points = points + 10 WHERE user_id = 2;  -- 포인트 지급

COMMIT;  -- 명시적으로 트랜잭션 반영

```

---

## **🔹 트랜잭션 격리 수준 (Isolation Level)**

트랜잭션이 실행될 때, **다른 트랜잭션과의 상호작용을 어떻게 조절할 것인지**를 결정하는 것이 **격리 수준(Isolation Level)** 입니다.

| **격리 수준** | **설명** | **발생할 수 있는 문제** |
| --- | --- | --- |
| **READ UNCOMMITTED** | 다른 트랜잭션이 `COMMIT`하지 않은 데이터도 읽을 수 있음 | **Dirty Read** |
| **READ COMMITTED (기본)** | `COMMIT`된 데이터만 읽을 수 있음 | **Non-repeatable Read** |
| **REPEATABLE READ** | 트랜잭션이 시작될 때 조회한 데이터는 변하지 않음 | **Phantom Read** |
| **SERIALIZABLE** | 트랜잭션이 순차적으로 실행됨 (가장 엄격, 성능 저하) | 없음 (완전한 데이터 일관성 보장) |

✅ 일반적으로 **READ COMMITTED**가 가장 많이 사용됨.

✅ 금융, 은행과 같이 강력한 데이터 정합성이 필요한 경우 **SERIALIZABLE**을 사용함.

---

## **🔹 트랜잭션과 프로시저 (Transaction + Procedure)**

트랜잭션을 **프로시저(Procedure)에서 활용**하면, **대량의 데이터 작업을 안정적으로 수행**할 수 있습니다.

### **✅ 트랜잭션을 포함한 프로시저 예제**

```sql
sql
복사편집
DELIMITER $$

CREATE PROCEDURE transferMoney(IN sender INT, IN receiver INT, IN amount DECIMAL(10,2))
BEGIN
    DECLARE error_flag INT DEFAULT 0;

    START TRANSACTION;

    -- 송금자 계좌에서 출금
    UPDATE accounts SET balance = balance - amount WHERE account_id = sender;
    IF ROW_COUNT() = 0 THEN
        SET error_flag = 1;  -- 계좌가 존재하지 않는 경우
    END IF;

    -- 수신자 계좌로 입금
    UPDATE accounts SET balance = balance + amount WHERE account_id = receiver;
    IF ROW_COUNT() = 0 THEN
        SET error_flag = 1;
    END IF;

    -- 에러가 발생하면 롤백
    IF error_flag = 1 THEN
        ROLLBACK;
    ELSE
        COMMIT;
    END IF;
END $$

DELIMITER ;

```

📌 **설명**

- `START TRANSACTION;` → 트랜잭션 시작
- `IF ROW_COUNT() = 0 THEN SET error_flag = 1;` → 계좌가 없거나 업데이트되지 않으면 에러 플래그 설정
- `ROLLBACK;` → 하나라도 실패하면 전체 취소
- `COMMIT;` → 모두 성공하면 적용

---

## **🔹 트랜잭션 vs. 락(Lock)**

트랜잭션과 **락(Lock, 잠금)은 데이터의 정합성을 보장하기 위한 기술**이지만, 개념이 다릅니다.

| **구분** | **트랜잭션(Transaction)** | **락(Lock)** |
| --- | --- | --- |
| **목적** | 여러 SQL 연산을 하나의 단위로 실행 | 특정 데이터(행, 테이블 등)에 대한 접근을 제한 |
| **작동 방식** | `COMMIT` 또는 `ROLLBACK`으로 데이터 적용 여부 결정 | `SHARED LOCK(공유락)`, `EXCLUSIVE LOCK(배타락)` 등을 이용해 데이터 접근을 제한 |
| **사용 예시** | 송금, 상품 주문, 포인트 차감 등 | 동시 업데이트 방지, 동시 읽기 허용 |

✅ 트랜잭션을 사용하면 **일관된 데이터 처리가 가능**하지만, 다수의 사용자가 동시 접근하는 경우 **락을 함께 사용하여 동기화 처리**할 수도 있습니다.

---

## **🔹 결론**

✅ **트랜잭션은 데이터베이스에서 논리적인 작업 단위를 구성하여, 데이터의 일관성과 무결성을 유지하는 기능**입니다.

✅ **ACID 원칙(Atomicity, Consistency, Isolation, Durability)을 만족해야 하며, COMMIT과 ROLLBACK을 사용하여 트랜잭션을 제어**할 수 있습니다.

✅ **트랜잭션 격리 수준을 조정하여 동시성 문제를 해결할 수 있으며, 프로시저에서도 트랜잭션을 활용할 수 있음**.
